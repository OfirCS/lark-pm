// Auto-create tickets from analyzed feedback
// Supports: Linear, Jira, GitHub Issues, Notion, Slack

import { AnalyzedFeedback, Priority } from './analyzer';
import { createTicket, TicketData, IntegrationConfig, IntegrationPlatform, TicketResult } from '../integrations';

export interface TicketCreationConfig {
  platform: IntegrationPlatform;
  config: IntegrationConfig;
  // Filters
  minPriority?: Priority; // Only create tickets for this priority or higher
  categories?: string[]; // Only these categories (e.g., ['bug', 'feature_request'])
  // Options
  addSourceLink?: boolean;
  addAnalysisTags?: boolean;
  dryRun?: boolean; // Don't actually create, just return what would be created
}

export interface SlackNotificationConfig {
  webhookUrl: string;
  channel?: string;
  mentionOnUrgent?: string; // e.g., "@channel" or "<@U123456>"
}

export interface TicketCreationResult {
  created: TicketResult[];
  skipped: { feedback: AnalyzedFeedback; reason: string }[];
  errors: { feedback: AnalyzedFeedback; error: string }[];
}

const PRIORITY_ORDER: Record<Priority, number> = {
  urgent: 4,
  high: 3,
  medium: 2,
  low: 1,
};

// Create tickets for analyzed feedback
export async function createTicketsFromFeedback(
  feedback: AnalyzedFeedback[],
  config: TicketCreationConfig
): Promise<TicketCreationResult> {
  const result: TicketCreationResult = {
    created: [],
    skipped: [],
    errors: [],
  };

  const minPriorityLevel = config.minPriority ? PRIORITY_ORDER[config.minPriority] : 0;

  for (const item of feedback) {
    // Check priority filter
    if (PRIORITY_ORDER[item.priority] < minPriorityLevel) {
      result.skipped.push({
        feedback: item,
        reason: `Priority ${item.priority} below minimum ${config.minPriority}`,
      });
      continue;
    }

    // Check category filter
    if (config.categories && !config.categories.includes(item.category)) {
      result.skipped.push({
        feedback: item,
        reason: `Category ${item.category} not in allowed list`,
      });
      continue;
    }

    // Build ticket data
    const ticketData: TicketData = {
      title: item.suggestedTitle,
      description: buildTicketDescription(item, config),
      priority: item.priority,
      labels: config.addAnalysisTags ? [...item.tags, item.category] : undefined,
      source: {
        type: item.source.startsWith('file:') ? 'manual' :
              item.source.includes('reddit') ? 'reddit' :
              item.source.includes('twitter') ? 'twitter' : 'support',
        url: item.metadata?.url as string | undefined,
        author: item.author,
      },
    };

    // Dry run - don't create
    if (config.dryRun) {
      result.created.push({
        success: true,
        ticketId: 'DRY_RUN',
        ticketUrl: '#dry-run',
        platform: config.platform,
      });
      continue;
    }

    // Create the ticket
    try {
      const ticketResult = await createTicket(config.platform, ticketData, config.config);

      if (ticketResult.success) {
        result.created.push(ticketResult);
      } else {
        result.errors.push({
          feedback: item,
          error: ticketResult.error || 'Unknown error',
        });
      }
    } catch (error) {
      result.errors.push({
        feedback: item,
        error: error instanceof Error ? error.message : 'Failed to create ticket',
      });
    }
  }

  return result;
}

function buildTicketDescription(item: AnalyzedFeedback, config: TicketCreationConfig): string {
  const parts: string[] = [];

  // Summary
  parts.push(`## Summary\n${item.summary}`);

  // Original feedback
  parts.push(`## Original Feedback\n> ${item.content}`);

  // Analysis details
  parts.push(`## Analysis
- **Category:** ${formatCategory(item.category)}
- **Sentiment:** ${formatSentiment(item.sentiment)}
- **Priority Score:** ${item.priorityScore}/100
- **Product Area:** ${item.productArea || 'Not specified'}`);

  // Tags
  if (item.tags.length > 0) {
    parts.push(`- **Tags:** ${item.tags.join(', ')}`);
  }

  // Source info
  if (item.source || item.author || item.date) {
    parts.push(`## Source
- **From:** ${item.source}${item.author ? ` by ${item.author}` : ''}${item.date ? ` on ${item.date}` : ''}`);
  }

  // Footer
  parts.push(`\n---\n_Auto-generated by Lark AI_`);

  return parts.join('\n\n');
}

function formatCategory(category: string): string {
  const icons: Record<string, string> = {
    bug: 'üêõ Bug',
    feature_request: '‚ú® Feature Request',
    complaint: 'üò§ Complaint',
    praise: 'üéâ Praise',
    question: '‚ùì Question',
    other: 'üìù Other',
  };
  return icons[category] || category;
}

function formatSentiment(sentiment: string): string {
  const icons: Record<string, string> = {
    positive: 'üü¢ Positive',
    neutral: 'üü° Neutral',
    negative: 'üî¥ Negative',
  };
  return icons[sentiment] || sentiment;
}

// Send Slack notification with summary
export async function sendSlackDigest(
  feedback: AnalyzedFeedback[],
  config: SlackNotificationConfig,
  ticketResults?: TicketCreationResult
): Promise<boolean> {
  const urgentCount = feedback.filter(f => f.priority === 'urgent').length;
  const highCount = feedback.filter(f => f.priority === 'high').length;
  const bugCount = feedback.filter(f => f.category === 'bug').length;
  const featureCount = feedback.filter(f => f.category === 'feature_request').length;
  const negativeCount = feedback.filter(f => f.sentiment === 'negative').length;

  const blocks: unknown[] = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: `üê¶ Lark Daily Digest`,
        emoji: true,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${feedback.length} feedback items* processed`,
      },
    },
    {
      type: 'section',
      fields: [
        { type: 'mrkdwn', text: `*üö® Urgent:* ${urgentCount}` },
        { type: 'mrkdwn', text: `*‚ö†Ô∏è High:* ${highCount}` },
        { type: 'mrkdwn', text: `*üêõ Bugs:* ${bugCount}` },
        { type: 'mrkdwn', text: `*‚ú® Features:* ${featureCount}` },
        { type: 'mrkdwn', text: `*üò§ Negative:* ${negativeCount}` },
        { type: 'mrkdwn', text: `*üìã Created:* ${ticketResults?.created.length || 0}` },
      ],
    },
  ];

  // Add urgent items if any
  if (urgentCount > 0 && config.mentionOnUrgent) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `${config.mentionOnUrgent} *Urgent items need attention!*`,
      },
    });

    const urgentItems = feedback.filter(f => f.priority === 'urgent').slice(0, 3);
    urgentItems.forEach(item => {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `> ${item.suggestedTitle}\n_${item.summary}_`,
        },
      });
    });
  }

  // Top feature requests
  const topFeatures = feedback
    .filter(f => f.category === 'feature_request')
    .sort((a, b) => b.priorityScore - a.priorityScore)
    .slice(0, 3);

  if (topFeatures.length > 0) {
    blocks.push({
      type: 'divider',
    });
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*Top Feature Requests:*',
      },
    });
    topFeatures.forEach((item, i) => {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${i + 1}. *${item.suggestedTitle}* (score: ${item.priorityScore})`,
        },
      });
    });
  }

  try {
    const response = await fetch(config.webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        channel: config.channel,
        blocks,
      }),
    });

    return response.ok;
  } catch (error) {
    console.error('Slack notification error:', error);
    return false;
  }
}
